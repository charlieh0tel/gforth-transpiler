# Builtin FORTH word definitions (except for defining words
# and string literals handled in pile.py).
#
# Clauses start when one of the following words in in column 1.
# The body of each clause must be indented, with space in column 1.
#
# def -- raw C++; must manipulate stacks manually.
# : -- defined in terms of forth words.
#
# Special forms that manipulate the stack for you:
#
# un -- unary function computes word z given word a.
# bin -- binary function computes word z given word a & word b.
# fun -- binary function computes double z given double a & double b
#          ( that is, C double float;  not forth "d" double int ).
# fbin -- binary function computes double z given double a & double b.
# fbinw -- binary function computes word z given double a & double b.
#
# See vm.h for more about stacks.
#
def utime
  int gettimeofday(struct timeval *tv, struct timezone *tz);
  struct timeval tv;
  gettimeofday(&tv, nullptr);
  long long x = 1000000 * (long long)tv.tv_sec + (long long)tv.tv_usec;
  word a, b;
  LongLongToPair(x, &b, &a);
  push(a); push(b);
def cmove
  word len = pop();
  char* to = (char*)pop();
  char* from = (char*)pop();
  for (word i=0; i<len; i++) to[i] = from[i];
  
def true
  push(-1);
def false
  push(0);
un 0<>
  z = B(a != 0);
un w@
  short* p= (short*)a;
  z = *p;
def d-
  word d = pop();
  word c = pop();
  word b = pop();
  word a = pop();
  long long z = PairToLongLong(b,a) - PairToLongLong(d,c);
  word x, y;
  LongLongToPair(z, &y, &x);
  push(x);
  push(y);
def 2swap
  word d = pop();
  word c = pop();
  word b = pop();
  word a = pop();
  push(c);
  push(d);
  push(a);
  push(b);
def */
  word c = pop();
  word b = pop();
  word a = pop();
  long long x = (long long)a * (long long)b;
  x = x / (long long)c;
  push((word)c);
  
def break:
  abort();
def s>f
  word x = pop();
  fpush((double)x);
un negate
  z = -a;
un abs
  z = (a<0) ? -a : a;
bin min
  z = (a<b) ? a : b;
bin max
  z = (a<b) ? b : a;
def d0>
  word hi = pop();
  word lo = pop();
  assert(hi == 0 || hi == -1);
  push (lo > 0);
  
def d.
  word hi = pop();
  word lo = pop();
  assert(hi == 0 || hi == -1);
  printf("%ld ", lo);
    fflush(stdout);
def throw
  word x = pop();
  if (x) abort();
def type
  word len = pop();
  char* addr = (char*)pop();
  for (int i = 0; i < len; i++) putchar(addr[i]);

def count
  char* addr = (char*)pop();
  word len = 255 & (word)(*addr);
  push((word)addr+1);
  push(len);
  
def bye
  exit(0);
def quit
  exit(0);
def 2drop
  dp -= 2;
def 2dup
  word a = ds[dp-1];
  word b = ds[dp];
  push(a);
  push(b);
def d>s
  word hi = pop();
  assert(hi == 0 || hi == -1);
  // Leave lo on stack.
def s>d
  word x = ds[dp];
  if (x<0) {
    push(-1);
  } else {
    push(0);
  }
  
def s>unumber?
  word len = pop();
  char* addr = (char*)pop();
  char* buffer = (char*)malloc(len+1);
  memset(buffer, 0, len+1);
  memcpy(buffer, addr, len);
  word x = atoi(buffer);
  free(buffer);
  push(x);  // lo
  push(x<0 ? -1 : 0);  // hi
  push(B(1));
def c@
  char* addr = (char*)pop();
  word ch = 255 & (word)(*addr);
  push(ch);
def c!
  char* addr = (char*)pop();
  word ch = pop();
  *addr = (char)ch;
def accept
  word max_len = pop();
  char* buffer = (char*) pop();
  memset(buffer, 0, max_len);
  char* ok = fgets(buffer, max_len-1, stdin);
  assert(ok);
  int n = strlen(buffer);
  if (buffer[n-1] == '\n') buffer[n-1] = '\0';
  push(strlen(buffer));
    
def +place
  char* whither = (char*) pop();
  word len = pop();
  assert(len < 256);
  char* whence = (char*) pop();
  word old_len = whither[0];
  assert(len + old_len < 256);
  whither[0] = len + old_len;
  for (word i = 0; i < len; i++) whither[i+old_len+1] = whence[i];

def place
  char* whither = (char*) pop();
  word len = pop();
  assert(len < 256);
  char* whence = (char*) pop();
  whither[0] = len;
  for (word i = 0; i < len; i++) whither[i+1] = whence[i];

: decimal
  ;  \ always in decimal, for now.
def open-file
  pop(); // how
  word n = pop();
  char* a = (char*) pop();

  char* fname = (char*) malloc(n+1);
  memset(fname, 0, n+1);
  memcpy(fname, a, n);

  FILE* fd = fopen(fname, "r");
  SAY(stderr, "=== open-file: `%s` => %ld, %d\n", fname, (word)fd, errno);
  free(fname);
  if (fd) { // good
    push((word)fd);
    push(0);
  } else { // err
    push(0);
    push(errno? errno: 255); // nonzero
  }
def open-pipe
  word how = pop(); // how
  assert(how == O_RDONLY);
  word n = pop();
  char* a = (char*) pop();

  char* fname = (char*) malloc(n+1);
  memset(fname, 0, n+1);
  memcpy(fname, a, n);

  FILE* fd = popen(fname, "r");
  SAY(stderr, "=== open-pipe: `%s` => %ld, %d\n", fname, (word)fd, errno);
  free(fname);
  if (fd) { // good
    push((word)fd);
    push(0);
  } else { // err
    push(0);
    push(errno? errno: 255); // nonzero
  }
def create-file
  pop(); // how
  word n = pop();
  char* a = (char*) pop();

  char* fname = (char*) malloc(n+1);
  memset(fname, 0, n+1);
  memcpy(fname, a, n);

  FILE* fd = fopen(fname, "w");
  SAY(stderr, "=== create-file: `%s` => %ld, %d\n", fname, (word)fd, errno);
  free(fname);
  if (fd) { // good
    push((word)fd);
    push(0);
  } else { // err
    push(0);
    push(errno? errno: 255); // nonzero
  }
def delete-file
  word n = pop();
  char* a = (char*) pop();

  char* fname = (char*) malloc(n+1);
  memset(fname, 0, n+1);
  memcpy(fname, a, n);

  SAY(stderr, "=== delete-file: `%s`\n", fname);
  SAY(stderr, "\nSHOULD DELETE FILE: %s\n", fname);
  free(fname);

def read-file
  FILE* file = (FILE*)pop();
  word len = pop();
  char* addr = (char*)pop();
  size_t n = fread(addr, len, 1, file);
  if (n==1) {
    push(len);  // num bytes read
    push(0);    // wior
  } else {
    push(0);  // num bytes read
    push(errno? errno: 255); // wior
  }
def write-file
  FILE* file = (FILE*)pop();
  word len = pop();
  char* addr = (char*)pop();
  size_t n = fwrite(addr, len, 1, file);
  if (n==1) {
    push(0);
  } else {
    push(errno? errno: 255);
  }
def close-file
  FILE* file = (FILE*)pop();
  fclose(file);
  push(0);
def file-size
  FILE* file = (FILE*)pop();
  int fd = fileno(file);
  struct stat st{};
  int e = fstat(fd, &st);
  if (e) {
    push(-1);
    push(-1);
    push(errno);
  } else {
    word sz = (word)st.st_size;
    push(sz);
    push(0);
    push(0);
  }

def r/o
  ds[++dp] = O_RDONLY;
def r/w
  ds[++dp] = O_RDWR | O_CREAT;
def erase
  word n = pop();
  char* p = (char*) pop();
  SAY(stderr, "=== erase: %ld bytes at %ld\n", n, (word)p);
  memset(p, 0, (size_t)n);
def falign
  here = ~(word)(7) & (here + 7);
#un fcells
#  z = 8 * a;
def allot
  SAY(stderr, "=== pre-allot: here = %ld\n", here);
  word len = pop();
  word z = here;
  here += len;
  SAY(stderr, "=== post-allot: here = %ld\n", here);
def i
  ds[++dp] = rs[rp];
def j
  ds[++dp] = rs[rp-2];
def must
  if (0 == ds[dp--]) {
    fflush(stdout);
    SAY(stderr, "\n****** FAILURE IN must ******\n");
    fflush(stderr);
    abort();
  }
def ~
  if (dp) {
    fflush(stdout);
    SAY(stderr, "\ndp is %ld want 0\n", dp);
    fflush(stderr);
    abort();
  }
  if (rp) {
    fflush(stdout);
    SAY(stderr, "\ndp is %ld want 0\n", rp);
    fflush(stderr);
    abort();
  }
  if (fp) {
    fflush(stdout);
    SAY(stderr, "\ndp is %ld want 0\n", fp);
    fflush(stderr);
    abort();
  }
def .
  printf("%ld ", ds[dp--]);
    fflush(stdout);
def f.
  printf("%.15g ", fs[fp--]);
    fflush(stdout);
def cr
  printf("\n");
    fflush(stdout);
def dup
  dp++;
  ds[dp] = ds[dp-1];
def over
  dp++;
  ds[dp] = ds[dp-2];
def swap
  word tmp = ds[dp];
  ds[dp] = ds[dp-1];
  ds[dp-1] = tmp;
def rot
  word tmp = ds[dp-2];
  ds[dp-2] = ds[dp-1];
  ds[dp-1] = ds[dp];
  ds[dp] = tmp;
def -rot
  word tmp = ds[dp];
  ds[dp] = ds[dp-1];
  ds[dp-1] = ds[dp-2];
  ds[dp-2] = tmp;
def !
  word* p = (word*)ds[dp--];
  *p = ds[dp--];
def @
  word* p = (word*)ds[dp];
  ds[dp] = *p;
def f!
  double* p = (double*)ds[dp--];
  *p = fs[fp--];
def f@
  double* p = (double*)pop();
  fpush(*p);
def d>f
  word b = pop();
  word a = pop();
  long long x = PairToLongLong(b, a);
  fs[++fp] = (double)x;
def drop
  --dp;
def 2@
  word* a = (word*)ds[dp];
  ds[dp] = a[0];
  ds[++dp] = a[1];
un cells
  z = sizeof(word) * a;
un 0=
  z = B(a==0);
un 1+
  z = a+1;
un 1-
  z = a-1;
bin =
  z = B(a == b);
bin <>
  z = B(a != b);
bin /=
  z = B(a != b);
bin <
  z = B(a < b);
bin <=
  z = B(a <= b);
bin >
  z = B(a > b);
bin >=
  z = B(a >= b);
bin u<
  z = B((uword)a < (uword)b);
bin u<=
  z = B((uword)a <= (uword)b);
bin u>
  z = B((uword)a > (uword)b);
bin u>=
  z = B((uword)a >= (uword)b);
bin and
  z = a & b;
bin or
  z = a | b;
bin xor
  z = a ^ b;
bin +
  z = a + b;
bin -
  z = a - b;
bin *
  z = a * b;
bin /
  z = a / b;
bin mod
  z = a % b;
def fdup
  fs[fp+1] = fs[fp];
  fp++;
fbin f+
  z = a + b;
fbin f-
  z = a - b;
fbin f*
  z = a * b;
fbin f/
  z = a / b;
fbin f**
  z = pow(a, b);
fbinw f=
  z = (a == b);
fbinw f/=
  z = (a != b);
fbinw f<>
  z = (a != b);
fbinw f<
  z = (a < b);
fbinw f<=
  z = (a <= b);
fbinw f>
  z = (a > b);
fbinw f>=
  z = (a >= b);
fun sin
  z = sin(a);
fun cos
  z = cos(a);
fun tan
  z = tan(a);
fun asin
  z = asin(a);
fun acos
  z = acos(a);
fun atan
  z = atan(a);
